# ü§ñ Tu Yo Virtual Profesional - CrewAI Nativo con YAML
# Usando archivos agents.yaml y tasks.yaml con DeepSeek

import os
import smtplib
import asyncio
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Dict, Any
from contextlib import asynccontextmanager

# Telegram Bot
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes

# CrewAI Framework - NATIVO con YAML
from crewai import Crew

# FastAPI for Railway deployment
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

# Configuration
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
DEEPSEEK_API_KEY = os.getenv('DEEPSEEK_API_KEY')
DEEPSEEK_BASE_URL = os.getenv('DEEPSEEK_BASE_URL', 'https://api.deepseek.com/v1')
WEBHOOK_URL = os.getenv('WEBHOOK_URL', '')
PORT = int(os.getenv('PORT', 8000))

# Email notification settings
EMAIL_USER = os.getenv('EMAIL_USER')
EMAIL_PASS = os.getenv('EMAIL_PASS')
NOTIFICATION_EMAIL = os.getenv('NOTIFICATION_EMAIL')

# IMPORTANTE: Configurar variables de entorno para DeepSeek
os.environ["OPENAI_API_KEY"] = DEEPSEEK_API_KEY
os.environ["OPENAI_API_BASE"] = DEEPSEEK_BASE_URL

class DigitalTwin:
    """ü§ñ Tu representante virtual usando CrewAI con YAML"""
    
    def __init__(self):
        self.cv_data = self.load_cv_data()
        self.crew = None
        self.setup_crew()
    
    def load_cv_data(self) -> Dict[str, Any]:
        """Carga tu informaci√≥n profesional COMPLETA desde VARIABLES DE ENTORNO"""
        return {
            "name": os.getenv('CV_NAME', 'Norbert Rodr√≠guez Sagarra'),
            "title": os.getenv('CV_TITLE', 'Senior AI Engineer & Intelligent Apps Project Manager'),
            "location": os.getenv('CV_LOCATION', 'Barcelona, Espa√±a'),
            "bio": os.getenv('CV_BIO', 'Apasionado por la IA, datos y eficiencia...'),
            "personality": os.getenv('CV_PERSONALITY', 'Anal√≠tico, innovador, estrat√©gico...'),
            
            # Skills completos
            "skills": os.getenv('CV_SKILLS', 'Python,LangGraph,CrewAI,OpenAI API,LangChain').split(','),
            
            # TODAS las experiencias (3 completas)
            "experience": [
                {
                    "company": os.getenv('CV_EXP1_COMPANY', 'VEOLIA-AGBAR-SYNECTIC (DEVOTEAM)'),
                    "role": os.getenv('CV_EXP1_ROLE', 'Senior AI Engineer & Project Manager'),
                    "years": os.getenv('CV_EXP1_YEARS', '2021-2024'),
                    "highlights": os.getenv('CV_EXP1_HIGHLIGHTS', 'Dise√±o e implementaci√≥n de agentes IA avanzados...')
                },
                {
                    "company": os.getenv('CV_EXP2_COMPANY', 'IBM Collaborative Projects (Freelance)'),
                    "role": os.getenv('CV_EXP2_ROLE', 'AI Solutions Architect & Team Lead'),
                    "years": os.getenv('CV_EXP2_YEARS', '2017-2022'),
                    "highlights": os.getenv('CV_EXP2_HIGHLIGHTS', 'Liderazgo de proyectos IA con Watson...')
                },
                {
                    "company": os.getenv('CV_EXP3_COMPANY', 'Enterprise Consulting & Training'),
                    "role": os.getenv('CV_EXP3_ROLE', 'Tech Lead & Mobile Solutions Architect'),
                    "years": os.getenv('CV_EXP3_YEARS', '2017'),
                    "highlights": os.getenv('CV_EXP3_HIGHLIGHTS', 'Liderazgo de equipos desarrollo Android/iOS...')
                }
            ],
            
            # TODOS los proyectos (5 completos)
            "projects": [
                {
                    "name": os.getenv('CV_PROJ1_NAME', 'Enterprise AI Assistant Ecosystem'),
                    "tech": os.getenv('CV_PROJ1_TECH', 'LangGraph + CrewAI + Multiple LLMs + FastAPI + Snowflake'),
                    "description": os.getenv('CV_PROJ1_DESC', 'Sistema completo de asistentes IA para 50k+ empleados...')
                },
                {
                    "name": os.getenv('CV_PROJ2_NAME', 'AI-Powered Hydroelectric Prediction Platform'),
                    "tech": os.getenv('CV_PROJ2_TECH', 'Python + TensorFlow + BigQuery + Airflow + PowerBI + GCP'),
                    "description": os.getenv('CV_PROJ2_DESC', 'Plataforma ML para predicci√≥n energ√≠a hidroel√©ctrica...')
                },
                {
                    "name": os.getenv('CV_PROJ3_NAME', 'Intelligent Data Orchestration Suite'),
                    "tech": os.getenv('CV_PROJ3_TECH', 'Talend + DBT + Spark + SCADA + LangChain + Vector DBs'),
                    "description": os.getenv('CV_PROJ3_DESC', 'Orquestaci√≥n inteligente datos multi-origen con IA...')
                },
                {
                    "name": os.getenv('CV_PROJ4_NAME', 'AI-Enhanced Enterprise Data Mining'),
                    "tech": os.getenv('CV_PROJ4_TECH', 'Python + Watson + Beautiful Soup + Apache Kafka + MLOps'),
                    "description": os.getenv('CV_PROJ4_DESC', 'Sistema scraping B2B con IA para an√°lisis competencia...')
                },
                {
                    "name": os.getenv('CV_PROJ5_NAME', 'Cybersecurity AI Analyst'),
                    "tech": os.getenv('CV_PROJ5_TECH', 'Python + Metasploit + NMAP + LangChain + Vector Search'),
                    "description": os.getenv('CV_PROJ5_DESC', 'Asistente IA para an√°lisis vulnerabilidades...')
                }
            ],
            
            # Informaci√≥n adicional completa
            "availability": os.getenv('CV_AVAILABILITY', 'Disponible para proyectos de IA, consultor√≠a y transformaci√≥n digital'),
            "education": os.getenv('CV_EDUCATION', 'BSc Data Science (UCM), Master Prompt Engineering...'),
            "ai_specialties": os.getenv('CV_AI_SPECIALTIES', 'LLM Orchestration,Agentic Workflows,RAG Systems...').split(','),
            "achievements": os.getenv('CV_ACHIEVEMENTS', 'Modernized legacy data ecosystems...'),
            "values": os.getenv('CV_VALUES', 'Driven by making the world better through useful technology...'),
            "languages": os.getenv('CV_LANGUAGES', 'Espa√±ol (nativo), Catal√°n (nativo), Ingl√©s (B2)'),
            "additional_projects": os.getenv('CV_ADDITIONAL_PROJECTS', 'CrewAI Multi-Agent Trading Bot...'),
            "additional_info": os.getenv('CV_ADDITIONAL_INFO', 'GitHub: n0r0s4, Kaggle: n0r0s4...')
        }
    
    def setup_crew(self):
        """Configura el crew con debugging completo para Railway"""
        try:
            print("üîç DEBUGGING CREW SETUP EN RAILWAY:")
            
            # 1. Verificar variables de entorno cr√≠ticas
            print(f"üìã DEEPSEEK_API_KEY configurada: {bool(DEEPSEEK_API_KEY)}")
            print(f"üìã DEEPSEEK_BASE_URL: {DEEPSEEK_BASE_URL}")
            print(f"üìã Variables OpenAI: {bool(os.getenv('OPENAI_API_KEY'))}")
            
            # 2. Verificar archivos YAML
            import os
            current_dir = os.getcwd()
            print(f"üìÅ Directorio actual: {current_dir}")
            
            # Listar archivos en el directorio
            files = os.listdir('.')
            print(f"üìÅ Archivos en directorio: {files}")
            
            yaml_files = ['agents.yaml', 'tasks.yaml']
            yaml_exists = {}
            for file in yaml_files:
                exists = os.path.exists(file)
                yaml_exists[file] = exists
                print(f"üìÑ {file}: {'‚úÖ EXISTE' if exists else '‚ùå NO EXISTE'}")
                
                if exists:
                    # Verificar que se puede leer
                    try:
                        with open(file, 'r', encoding='utf-8') as f:
                            content = f.read()
                            print(f"üìÑ {file} size: {len(content)} chars")
                    except Exception as e:
                        print(f"‚ùå Error leyendo {file}: {e}")
            
            # 3. Intentar crear crew
            if all(yaml_exists.values()):
                print("üöÄ Intentando crear Crew con archivos YAML...")
                try:
                    # Asegurarse de que las variables de entorno est√©n configuradas
                    if not os.getenv('OPENAI_API_KEY'):
                        os.environ["OPENAI_API_KEY"] = DEEPSEEK_API_KEY
                        print("‚úÖ OPENAI_API_KEY configurada para DeepSeek")
                    
                    if not os.getenv('OPENAI_API_BASE'):
                        os.environ["OPENAI_API_BASE"] = DEEPSEEK_BASE_URL
                        print("‚úÖ OPENAI_API_BASE configurada para DeepSeek")
                    
                    # Crear crew con timeout
                    import signal
                    
                    def timeout_handler(signum, frame):
                        raise TimeoutError("Crew creation timed out")
                    
                    signal.signal(signal.SIGALRM, timeout_handler)
                    signal.alarm(30)  # 30 segundos timeout
                    
                    try:
                        self.crew = Crew()
                        signal.alarm(0)  # Cancelar timeout
                        print("‚úÖ Crew creado exitosamente con YAML")
                        return
                    except TimeoutError:
                        print("‚è∞ Timeout creando Crew - usando fallback")
                        signal.alarm(0)
                        self.crew = self.create_programmatic_crew()
                        return
                    
                except Exception as e:
                    print(f"‚ùå Error creando Crew con YAML: {e}")
                    print("üîÑ Fallback a configuraci√≥n program√°tica...")
                    self.crew = self.create_programmatic_crew()
                    return
            else:
                print("‚ùå Archivos YAML no encontrados - usando configuraci√≥n program√°tica")
                self.crew = self.create_programmatic_crew()
                return
            
        except Exception as e:
            print(f"üí• Error general en setup_crew: {e}")
            import traceback
            traceback.print_exc()
            print("üîÑ Fallback final a respuestas simples")
            self.crew = None
    
    def create_programmatic_crew(self):
        """Crea crew program√°ticamente con configuraci√≥n completa de Norbert"""
        try:
            print("üõ†Ô∏è Creando crew program√°tico...")
            
            # Import con timeout
            import signal
            
            def import_timeout(signum, frame):
                raise TimeoutError("Import timed out")
            
            signal.signal(signal.SIGALRM, import_timeout)
            signal.alarm(10)  # 10 segundos para import
            
            try:
                from crewai import Agent, Task
                signal.alarm(0)  # Cancelar timeout
            except TimeoutError:
                print("‚è∞ Timeout en import CrewAI")
                return None
            except Exception as e:
                print(f"‚ùå Error importando CrewAI: {e}")
                return None
                        
            # AGENTE PRINCIPAL - Norbert's Digital Twin
            norbert_agent = Agent(
                role='Senior AI Engineer & Professional Representative',
                goal=f'Represent {self.cv_data["name"]} professionally and generate quality leads',
                backstory=f'''You ARE {self.cv_data["name"]}, a {self.cv_data["title"]} from {self.cv_data["location"]}.
                
                BACKGROUND: {self.cv_data["bio"]}
                
                PERSONALITY: {self.cv_data["personality"]}
                
                TECHNICAL EXPERTISE: You have deep experience with {len(self.cv_data["skills"])} technologies including:
                - AI/ML: LangGraph, CrewAI, OpenAI API, LangChain, AutoGen, HuggingFace
                - Languages: Python, Java, JavaScript, PHP
                - Cloud: AWS, GCP, Azure
                - Data: Snowflake, BigQuery, Airflow
                - And many more: {", ".join(self.cv_data["skills"][:10])}...
                
                RECENT PROJECTS: You've built enterprise AI systems for 50k+ users, ML platforms processing 1M+ data points daily, and intelligent data orchestration suites.
                
                COMMUNICATION STYLE:
                - Speak in first person as Norbert
                - Be enthusiastic about AI and complex technical challenges
                - Show deep expertise while remaining approachable
                - Highlight relevant experience for each inquiry
                - Identify business opportunities naturally
                - Be authentic and passionate about technology
                
                Always represent Norbert's extensive AI expertise and leadership experience accurately.''',
                verbose=True,
                allow_delegation=False,
                max_iter=3
            )
            
            # TAREA PRINCIPAL - Respuesta profesional completa
            response_task = Task(
                description='''Analyze the user's query and provide a comprehensive, professional response as Norbert.
                
                AVAILABLE CONTEXT:
                - Complete professional background and experience
                - Technical skills across AI, data, cloud, and development
                - Detailed project portfolio including enterprise AI systems
                - Current availability and interests
                - User's specific query and intent
                
                RESPONSE REQUIREMENTS:
                1. Analyze what the user is asking about
                2. Provide relevant technical details from Norbert's experience
                3. Show enthusiasm for the technology/project mentioned
                4. Share specific examples from relevant projects when appropriate
                5. Maintain Norbert's authentic personality and communication style
                6. If user shows business interest, naturally guide toward contact exchange
                7. Keep response engaging, informative, and under 300 words
                
                USER QUERY: {query}
                
                Respond as Norbert would - technical, enthusiastic, and professional.''',
                agent=norbert_agent,
                expected_output='A personalized response from Norbert that addresses the query with relevant technical expertise, specific examples, and authentic personality while identifying potential business opportunities'
            )
            
            # CREAR CREW
            crew = Crew(
                agents=[norbert_agent],
                tasks=[response_task],
                verbose=True,
                memory=False  # Disable memory for Railway to avoid issues
            )
            
            print("‚úÖ Programmatic crew created successfully")
            return crew
            
        except Exception as e:
            print(f"Error creating programmatic crew: {e}")
            return None
    
    async def process_query(self, user_message: str, context: str = "") -> str:
        """Procesa consulta del usuario usando CrewAI"""
        
        if self.crew:
            try:
                # Preparar contexto completo para los agentes
                professional_context = f"""
                INFORMACI√ìN PROFESIONAL COMPLETA DE NORBERT:
                
                Nombre: {self.cv_data['name']}
                T√≠tulo: {self.cv_data['title']}
                Ubicaci√≥n: {self.cv_data['location']}
                Bio: {self.cv_data['bio']}
                Personalidad: {self.cv_data['personality']}
                Disponibilidad: {self.cv_data['availability']}
                
                SKILLS T√âCNICOS ({len(self.cv_data['skills'])} tecnolog√≠as):
                {', '.join(self.cv_data['skills'])}
                
                ESPECIALIDADES IA:
                {', '.join(self.cv_data.get('ai_specialties', []))}
                
                EXPERIENCIA LABORAL COMPLETA:
                """
                
                for i, exp in enumerate(self.cv_data['experience'], 1):
                    professional_context += f"""
                {i}. {exp['role']} en {exp['company']} ({exp['years']})
                   Logros: {exp['highlights']}
                """
                
                professional_context += f"""
                
                PROYECTOS DESTACADOS COMPLETOS ({len(self.cv_data['projects'])} proyectos):
                """
                
                for i, project in enumerate(self.cv_data['projects'], 1):
                    professional_context += f"""
                {i}. {project['name']} 
                   Tech Stack: {project['tech']}
                   Descripci√≥n: {project['description']}
                """
                
                professional_context += f"""
                
                EDUCACI√ìN Y CERTIFICACIONES:
                {self.cv_data.get('education', 'Informaci√≥n educativa completa disponible')}
                
                LOGROS Y RECONOCIMIENTOS:
                {self.cv_data.get('achievements', 'M√∫ltiples logros en transformaci√≥n digital')}
                
                FILOSOF√çA Y VALORES:
                {self.cv_data.get('values', 'Orientado a soluciones tecnol√≥gicas √∫tiles')}
                
                IDIOMAS:
                {self.cv_data.get('languages', 'Multiling√ºe')}
                
                PROYECTOS ADICIONALES:
                {self.cv_data.get('additional_projects', 'M√∫ltiples proyectos paralelos')}
                
                INFORMACI√ìN ADICIONAL:
                {self.cv_data.get('additional_info', 'Activo en comunidad tech')}
                
                CONSULTA DEL USUARIO:
                {user_message}
                
                CONTEXTO ADICIONAL:
                {context}
                """
                
                # Ejecutar crew con el contexto completo
                result = self.crew.kickoff(inputs={"query": professional_context})
                
                # Extraer el resultado final
                if hasattr(result, 'raw'):
                    return str(result.raw)
                else:
                    return str(result)
                
            except Exception as e:
                print(f"CrewAI execution error: {e}")
                return self.simple_response(user_message)
        else:
            return self.simple_response(user_message)
    
    def simple_response(self, user_message: str) -> str:
        """Respuesta simple basada en keywords (fallback)"""
        message_lower = user_message.lower()
        
        # Detectar tipo de consulta
        if any(word in message_lower for word in ['experiencia', 'experience', 'skills', 'tecnolog']):
            return f"""
üõ†Ô∏è **Mi experiencia t√©cnica:**

**Skills principales:** {', '.join(self.cv_data['skills'])}

**Experiencia reciente:**
{self.cv_data['experience'][0]['role']} en {self.cv_data['experience'][0]['company']} ({self.cv_data['experience'][0]['years']})
‚Ä¢ {self.cv_data['experience'][0]['highlights']}

¬øHay alguna tecnolog√≠a espec√≠fica que te interese conocer m√°s?
            """
        
        elif any(word in message_lower for word in ['proyecto', 'project', 'portfolio']):
            projects_text = "üöÄ **Mis proyectos destacados:**\n\n"
            for project in self.cv_data['projects']:
                projects_text += f"**{project['name']}**\n"
                projects_text += f"Tech: {project['tech']}\n"
                projects_text += f"{project['description']}\n\n"
            
            projects_text += "¬øTe interesa alguno en particular?"
            return projects_text
        
        elif any(word in message_lower for word in ['disponible', 'available', 'contratar', 'hire']):
            return f"""
üìÖ **Disponibilidad actual:**

{self.cv_data['availability']}

¬°Me interesa saber m√°s sobre tu proyecto! 

¬øPodr√≠as contarme:
‚Ä¢ ¬øQu√© tipo de proyecto es?
‚Ä¢ ¬øQu√© tecnolog√≠as necesitas?
‚Ä¢ ¬øCu√°l es tu email para mandarte m√°s info?
            """
        
        elif any(word in message_lower for word in ['contacto', 'contact', 'email', 'tel√©fono']):
            return """
üìß **¬°Perfecto! Quieres contactar conmigo**

Para conectarte directamente, por favor comp√°rteme:
‚Ä¢ üìß Tu email (obligatorio)
‚Ä¢ üì± Tu tel√©fono (opcional) 
‚Ä¢ üíº Breve descripci√≥n del proyecto

Te responder√© en menos de 24 horas.
            """
        
        else:
            return f"""
üëã ¬°Hola! Soy {self.cv_data['name']}, {self.cv_data['title']}.

{self.cv_data['bio']}

**Puedes preguntarme sobre:**
‚Ä¢ Mi experiencia t√©cnica
‚Ä¢ Proyectos que he realizado  
‚Ä¢ Disponibilidad para nuevos proyectos
‚Ä¢ C√≥mo contactarme

¬øEn qu√© puedo ayudarte espec√≠ficamente?
            """

class TelegramBot:
    """ü§ñ Bot de Telegram usando CrewAI con YAML"""
    
    def __init__(self):
        self.digital_twin = DigitalTwin()
        self.app = Application.builder().token(TELEGRAM_TOKEN).build()
        self.setup_handlers()
        
        # Para tracking de contactos
        self.collecting_contacts = set()
    
    def setup_handlers(self):
        """Configura handlers del bot"""
        self.app.add_handler(CommandHandler("start", self.start_command))
        self.app.add_handler(CommandHandler("help", self.help_command))
        self.app.add_handler(CommandHandler("portfolio", self.portfolio_command))
        self.app.add_handler(CallbackQueryHandler(self.handle_callback))
        self.app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """üöÄ Comando inicial"""
        cv = self.digital_twin.cv_data
        
        welcome = f"""
ü§ñ **¬°Hola! Soy el asistente virtual de {cv['name']}**

*{cv['bio']}*

üìç {cv['location']}
üíº {cv['title']}
‚ö° {cv['availability']}

**¬øQu√© te interesa saber?**
        """
        
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("üíº Ver Portfolio", callback_data="portfolio"),
                InlineKeyboardButton("üöÄ Proyectos", callback_data="projects")
            ],
            [
                InlineKeyboardButton("üìß Contactar", callback_data="contact"),
                InlineKeyboardButton("‚ùì Preguntar", callback_data="ask")
            ]
        ])
        
        await update.message.reply_text(welcome, parse_mode='Markdown', reply_markup=keyboard)
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """üìã Ayuda"""
        help_text = f"""
üìã **¬øEn qu√© puedo ayudarte?**

**Preg√∫ntame sobre:**
‚Ä¢ üíª Experiencia y skills t√©cnicos
‚Ä¢ üöÄ Proyectos realizados
‚Ä¢ üìÖ Disponibilidad para proyectos
‚Ä¢ üìß C√≥mo contactar con {self.digital_twin.cv_data['name']}

**Ejemplos de preguntas:**
‚Ä¢ "¬øTienes experiencia en React?"
‚Ä¢ "¬øQu√© proyectos has hecho?"
‚Ä¢ "¬øEst√°s disponible para un proyecto?"

*¬°Solo escribe tu pregunta!*
        """
        
        await update.message.reply_text(help_text, parse_mode='Markdown')
    
    async def portfolio_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """üíº Portfolio completo"""
        cv = self.digital_twin.cv_data
        
        portfolio = f"""
üíº **Portfolio de {cv['name']}**

**üõ†Ô∏è Skills:**
{', '.join(cv['skills'])}

**üíº Experiencia:**
"""
        
        for exp in cv['experience']:
            portfolio += f"""
**{exp['role']}** @ {exp['company']} ({exp['years']})
{exp['highlights']}

"""
        
        portfolio += "**üöÄ Proyectos:**\n"
        for project in cv['projects']:
            portfolio += f"""
**{project['name']}**
Tech: {project['tech']}
{project['description']}

"""
        
        portfolio += f"**üìã Estado:** {cv['availability']}"
        
        await update.message.reply_text(portfolio, parse_mode='Markdown')
    
    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Maneja botones"""
        query = update.callback_query
        await query.answer()
        
        if query.data == "portfolio":
            await self.portfolio_command(update, context)
        elif query.data == "projects":
            await self.show_projects(query)
        elif query.data == "contact":
            await self.start_contact_collection(query)
        elif query.data == "ask":
            await query.edit_message_text(
                "‚ùì **¬°Perfecto!** Escribe tu pregunta.\n\n"
                "*Ejemplo: '¬øTienes experiencia con APIs?'*",
                parse_mode='Markdown'
            )
    
    async def show_projects(self, query):
        """Muestra proyectos"""
        projects = self.digital_twin.cv_data['projects']
        
        text = "üöÄ **Proyectos Destacados:**\n\n"
        for i, project in enumerate(projects, 1):
            text += f"""
**{i}. {project['name']}**
üõ†Ô∏è {project['tech']}
üìã {project['description']}

"""
        text += "*¬øAlguno te llama la atenci√≥n?*"
        
        await query.edit_message_text(text, parse_mode='Markdown')
    
    async def start_contact_collection(self, query):
        """Inicia recolecci√≥n de contacto"""
        user_id = query.from_user.id
        self.collecting_contacts.add(user_id)
        
        text = f"""
üìß **Contactar con {self.digital_twin.cv_data['name']}**

*¬°Perfecto! Le har√© llegar tu informaci√≥n.*

**Comparte por favor:**
‚Ä¢ üìß Tu email
‚Ä¢ üì± Tu tel√©fono (opcional)
‚Ä¢ üíº Qu√© proyecto tienes en mente

**Ejemplo:**
"Mi email es juan@empresa.com
Necesito una web con React"

*Te responder√° en menos de 24 horas.*
        """
        
        await query.edit_message_text(text, parse_mode='Markdown')
    
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Maneja mensajes de texto usando CrewAI"""
        user_id = update.effective_user.id
        message = update.message.text
        
        # Si est√° en modo recolecci√≥n de contacto
        if user_id in self.collecting_contacts:
            await self.process_contact_info(update, message)
            return
        
        # Mostrar que est√° escribiendo
        await context.bot.send_chat_action(chat_id=update.effective_chat.id, action="typing")
        
        try:
            # Procesar con Digital Twin (CrewAI)
            response = await self.digital_twin.process_query(message)
            
            # Enviar respuesta
            await update.message.reply_text(response, parse_mode='Markdown')
            
            # Detectar si muestra inter√©s en contrataci√≥n
            if any(word in message.lower() for word in ['proyecto', 'contratar', 'hire', 'trabajo', 'presupuesto']):
                await asyncio.sleep(1)
                await update.message.reply_text(
                    "üí° *¬øTe interesa? Puedo conectarte directamente con √©l usando /contact*",
                    parse_mode='Markdown'
                )
        
        except Exception as e:
            print(f"Error processing message: {e}")
            await update.message.reply_text(
                "ü§ñ *Disculpa, hubo un peque√±o error. ¬øPuedes repetir?*",
                parse_mode='Markdown'
            )
    
    async def process_contact_info(self, update: Update, message: str):
        """Procesa informaci√≥n de contacto"""
        user_id = update.effective_user.id
        user_info = update.effective_user
        
        # Extraer email (b√°sico)
        import re
        email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        emails = re.findall(email_pattern, message)
        
        if emails:
            # Guardar lead
            lead_info = {
                "email": emails[0],
                "message": message,
                "telegram_user": user_info.username or user_info.first_name,
                "user_id": user_id
            }
            
            # Enviar notificaci√≥n
            await self.send_notification(lead_info)
            
            # Confirmar al usuario
            await update.message.reply_text(
                f"""
‚úÖ **¬°Perfecto! Informaci√≥n recibida**

üìß Email: {emails[0]}
üí¨ Mensaje: ‚úì

{self.digital_twin.cv_data['name']} recibir√° tu informaci√≥n y te contactar√° pronto.

*¬°Gracias por tu inter√©s!*
                """,
                parse_mode='Markdown'
            )
            
            # Quitar de modo recolecci√≥n
            self.collecting_contacts.discard(user_id)
            
        else:
            await update.message.reply_text(
                "üìß *No veo un email v√°lido. ¬øPuedes incluirlo?*\n\n"
                "*Ejemplo: juan@empresa.com*",
                parse_mode='Markdown'
            )