# ü§ñ Tu Yo Virtual Profesional - CrewAI Nativo con YAML
# Usando archivos agents.yaml y tasks.yaml con DeepSeek

import os
import smtplib
import asyncio
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Dict, Any
from contextlib import asynccontextmanager

# Telegram Bot
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes

# CrewAI Framework - NATIVO con YAML
from crewai import Crew

# FastAPI for Railway deployment
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

# Configuration
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
DEEPSEEK_API_KEY = os.getenv('DEEPSEEK_API_KEY')
DEEPSEEK_BASE_URL = os.getenv('DEEPSEEK_BASE_URL', 'https://api.deepseek.com/v1')
WEBHOOK_URL = os.getenv('WEBHOOK_URL', '')
PORT = int(os.getenv('PORT', 8000))

# Email notification settings
EMAIL_USER = os.getenv('EMAIL_USER')
EMAIL_PASS = os.getenv('EMAIL_PASS')
NOTIFICATION_EMAIL = os.getenv('NOTIFICATION_EMAIL')

# IMPORTANTE: Configurar variables de entorno para DeepSeek
os.environ["OPENAI_API_KEY"] = DEEPSEEK_API_KEY
os.environ["OPENAI_API_BASE"] = DEEPSEEK_BASE_URL

class DigitalTwin:
    """ü§ñ Tu representante virtual usando CrewAI con YAML"""
    
    def __init__(self):
        self.cv_data = self.load_cv_data()
        self.crew = None
        self.setup_crew()
    
    def load_cv_data(self) -> Dict[str, Any]:
        """Carga tu informaci√≥n profesional COMPLETA desde VARIABLES DE ENTORNO"""
        return {
            "name": os.getenv('CV_NAME', 'Norbert Rodr√≠guez Sagarra'),
            "title": os.getenv('CV_TITLE', 'Senior AI Engineer & Intelligent Apps Project Manager'),
            "location": os.getenv('CV_LOCATION', 'Barcelona, Espa√±a'),
            "bio": os.getenv('CV_BIO', 'Apasionado por la IA, datos y eficiencia...'),
            "personality": os.getenv('CV_PERSONALITY', 'Anal√≠tico, innovador, estrat√©gico...'),
            
            # Skills completos
            "skills": os.getenv('CV_SKILLS', 'Python,LangGraph,CrewAI,OpenAI API,LangChain').split(','),
            
            # TODAS las experiencias (3 completas)
            "experience": [
                {
                    "company": os.getenv('CV_EXP1_COMPANY', 'VEOLIA-AGBAR-SYNECTIC (DEVOTEAM)'),
                    "role": os.getenv('CV_EXP1_ROLE', 'Senior AI Engineer & Project Manager'),
                    "years": os.getenv('CV_EXP1_YEARS', '2021-2024'),
                    "highlights": os.getenv('CV_EXP1_HIGHLIGHTS', 'Dise√±o e implementaci√≥n de agentes IA avanzados...')
                },
                {
                    "company": os.getenv('CV_EXP2_COMPANY', 'IBM Collaborative Projects (Freelance)'),
                    "role": os.getenv('CV_EXP2_ROLE', 'AI Solutions Architect & Team Lead'),
                    "years": os.getenv('CV_EXP2_YEARS', '2017-2022'),
                    "highlights": os.getenv('CV_EXP2_HIGHLIGHTS', 'Liderazgo de proyectos IA con Watson...')
                },
                {
                    "company": os.getenv('CV_EXP3_COMPANY', 'Enterprise Consulting & Training'),
                    "role": os.getenv('CV_EXP3_ROLE', 'Tech Lead & Mobile Solutions Architect'),
                    "years": os.getenv('CV_EXP3_YEARS', '2017'),
                    "highlights": os.getenv('CV_EXP3_HIGHLIGHTS', 'Liderazgo de equipos desarrollo Android/iOS...')
                }
            ],
            
            # TODOS los proyectos (5 completos)
            "projects": [
                {
                    "name": os.getenv('CV_PROJ1_NAME', 'Enterprise AI Assistant Ecosystem'),
                    "tech": os.getenv('CV_PROJ1_TECH', 'LangGraph + CrewAI + Multiple LLMs + FastAPI + Snowflake'),
                    "description": os.getenv('CV_PROJ1_DESC', 'Sistema completo de asistentes IA para 50k+ empleados...')
                },
                {
                    "name": os.getenv('CV_PROJ2_NAME', 'AI-Powered Hydroelectric Prediction Platform'),
                    "tech": os.getenv('CV_PROJ2_TECH', 'Python + TensorFlow + BigQuery + Airflow + PowerBI + GCP'),
                    "description": os.getenv('CV_PROJ2_DESC', 'Plataforma ML para predicci√≥n energ√≠a hidroel√©ctrica...')
                },
                {
                    "name": os.getenv('CV_PROJ3_NAME', 'Intelligent Data Orchestration Suite'),
                    "tech": os.getenv('CV_PROJ3_TECH', 'Talend + DBT + Spark + SCADA + LangChain + Vector DBs'),
                    "description": os.getenv('CV_PROJ3_DESC', 'Orquestaci√≥n inteligente datos multi-origen con IA...')
                },
                {
                    "name": os.getenv('CV_PROJ4_NAME', 'AI-Enhanced Enterprise Data Mining'),
                    "tech": os.getenv('CV_PROJ4_TECH', 'Python + Watson + Beautiful Soup + Apache Kafka + MLOps'),
                    "description": os.getenv('CV_PROJ4_DESC', 'Sistema scraping B2B con IA para an√°lisis competencia...')
                },
                {
                    "name": os.getenv('CV_PROJ5_NAME', 'Cybersecurity AI Analyst'),
                    "tech": os.getenv('CV_PROJ5_TECH', 'Python + Metasploit + NMAP + LangChain + Vector Search'),
                    "description": os.getenv('CV_PROJ5_DESC', 'Asistente IA para an√°lisis vulnerabilidades...')
                }
            ],
            
            # Informaci√≥n adicional completa
            "availability": os.getenv('CV_AVAILABILITY', 'Disponible para proyectos de IA, consultor√≠a y transformaci√≥n digital'),
            "education": os.getenv('CV_EDUCATION', 'BSc Data Science (UCM), Master Prompt Engineering...'),
            "ai_specialties": os.getenv('CV_AI_SPECIALTIES', 'LLM Orchestration,Agentic Workflows,RAG Systems...').split(','),
            "achievements": os.getenv('CV_ACHIEVEMENTS', 'Modernized legacy data ecosystems...'),
            "values": os.getenv('CV_VALUES', 'Driven by making the world better through useful technology...'),
            "languages": os.getenv('CV_LANGUAGES', 'Espa√±ol (nativo), Catal√°n (nativo), Ingl√©s (B2)'),
            "additional_projects": os.getenv('CV_ADDITIONAL_PROJECTS', 'CrewAI Multi-Agent Trading Bot...'),
            "additional_info": os.getenv('CV_ADDITIONAL_INFO', 'GitHub: n0r0s4, Kaggle: n0r0s4...')
        }
    
    def setup_crew(self):
        """Configura el crew usando archivos YAML nativos con DeepSeek"""
        try:
            # SOLUCI√ìN CORREGIDA: Usar archivos YAML directamente
            # CrewAI buscar√° autom√°ticamente agents.yaml y tasks.yaml en la carpeta actual
            # o en la carpeta config/
            
            # Verificar que los archivos YAML existan
            import os
            yaml_files = ['agents.yaml', 'tasks.yaml']
            config_files = ['config/agents.yaml', 'config/tasks.yaml']
            
            # Buscar archivos YAML
            yaml_found = all(os.path.exists(f) for f in yaml_files)
            config_found = all(os.path.exists(f) for f in config_files)
            
            if yaml_found:
                # Archivos en directorio ra√≠z
                print("‚úÖ Usando archivos YAML en directorio ra√≠z")
                self.crew = Crew()
            elif config_found:
                # Archivos en carpeta config/
                print("‚úÖ Usando archivos YAML en carpeta config/")
                self.crew = Crew(config_path="config")
            else:
                # No hay archivos YAML, crear crew program√°ticamente
                print("‚ö†Ô∏è No se encontraron archivos YAML, usando configuraci√≥n por c√≥digo")
                self.crew = self.create_fallback_crew()
            
            print("‚úÖ CrewAI configurado correctamente")
            
        except Exception as e:
            print(f"Error setting up crew: {e}")
            print("üîÑ Intentando configuraci√≥n fallback...")
            self.crew = self.create_fallback_crew()
    
    def create_fallback_crew(self):
        """Crea crew program√°ticamente si no hay archivos YAML"""
        from crewai import Agent, Task
        
        try:
            # Crear agente principal
            cv_agent = Agent(
                role='Professional CV Expert & Representative',
                goal=f'Act as the professional representative of {self.cv_data["name"]}, showcasing experience and skills',
                backstory=f'''You are the virtual representative of {self.cv_data["name"]}, a skilled {self.cv_data["title"]}. 
                You know their complete career history, technical skills: {", ".join(self.cv_data["skills"])}, 
                and professional achievements.
                
                Personality: {self.cv_data["personality"]}
                
                You should:
                - Speak in first person as if you ARE {self.cv_data["name"]}
                - Be enthusiastic about technical projects
                - Highlight relevant experience for each question
                - Show personality while maintaining professionalism
                - Suggest next steps when someone shows interest''',
                verbose=True,
                allow_delegation=False
            )
            
            # Crear tarea principal
            response_task = Task(
                description='''Analyze the user query and provide a comprehensive professional response.
                
                User Query: {query}
                
                Professional Context Available:
                - Technical skills and experience
                - Project portfolio and achievements
                - Work history and current availability
                
                Provide a response that:
                - Directly answers their question
                - Highlights relevant experience
                - Shows enthusiasm and competence
                - Maintains authentic personality
                - Suggests logical next steps if appropriate''',
                agent=cv_agent,
                expected_output='A personalized, professional response that addresses the query and represents the professional authentically'
            )
            
            # Crear crew
            return Crew(
                agents=[cv_agent],
                tasks=[response_task],
                verbose=True
            )
            
        except Exception as e:
            print(f"Error creating fallback crew: {e}")
            return None
    
    async def process_query(self, user_message: str, context: str = "") -> str:
        """Procesa consulta del usuario usando CrewAI"""
        
        if self.crew:
            try:
                # Preparar contexto completo para los agentes
                professional_context = f"""
                INFORMACI√ìN PROFESIONAL COMPLETA DE NORBERT:
                
                Nombre: {self.cv_data['name']}
                T√≠tulo: {self.cv_data['title']}
                Ubicaci√≥n: {self.cv_data['location']}
                Bio: {self.cv_data['bio']}
                Personalidad: {self.cv_data['personality']}
                Disponibilidad: {self.cv_data['availability']}
                
                SKILLS T√âCNICOS ({len(self.cv_data['skills'])} tecnolog√≠as):
                {', '.join(self.cv_data['skills'])}
                
                ESPECIALIDADES IA:
                {', '.join(self.cv_data.get('ai_specialties', []))}
                
                EXPERIENCIA LABORAL COMPLETA:
                """
                
                for i, exp in enumerate(self.cv_data['experience'], 1):
                    professional_context += f"""
                {i}. {exp['role']} en {exp['company']} ({exp['years']})
                   Logros: {exp['highlights']}
                """
                
                professional_context += f"""
                
                PROYECTOS DESTACADOS COMPLETOS ({len(self.cv_data['projects'])} proyectos):
                """
                
                for i, project in enumerate(self.cv_data['projects'], 1):
                    professional_context += f"""
                {i}. {project['name']} 
                   Tech Stack: {project['tech']}
                   Descripci√≥n: {project['description']}
                """
                
                professional_context += f"""
                
                EDUCACI√ìN Y CERTIFICACIONES:
                {self.cv_data.get('education', 'Informaci√≥n educativa completa disponible')}
                
                LOGROS Y RECONOCIMIENTOS:
                {self.cv_data.get('achievements', 'M√∫ltiples logros en transformaci√≥n digital')}
                
                FILOSOF√çA Y VALORES:
                {self.cv_data.get('values', 'Orientado a soluciones tecnol√≥gicas √∫tiles')}
                
                IDIOMAS:
                {self.cv_data.get('languages', 'Multiling√ºe')}
                
                PROYECTOS ADICIONALES:
                {self.cv_data.get('additional_projects', 'M√∫ltiples proyectos paralelos')}
                
                INFORMACI√ìN ADICIONAL:
                {self.cv_data.get('additional_info', 'Activo en comunidad tech')}
                
                CONSULTA DEL USUARIO:
                {user_message}
                
                CONTEXTO ADICIONAL:
                {context}
                """
                
                # Ejecutar crew con el contexto completo
                result = self.crew.kickoff(inputs={"query": professional_context})
                
                # Extraer el resultado final
                if hasattr(result, 'raw'):
                    return str(result.raw)
                else:
                    return str(result)
                
            except Exception as e:
                print(f"CrewAI execution error: {e}")
                return self.simple_response(user_message)
        else:
            return self.simple_response(user_message)
    
    def simple_response(self, user_message: str) -> str:
        """Respuesta simple basada en keywords (fallback)"""
        message_lower = user_message.lower()
        
        # Detectar tipo de consulta
        if any(word in message_lower for word in ['experiencia', 'experience', 'skills', 'tecnolog']):
            return f"""
üõ†Ô∏è **Mi experiencia t√©cnica:**

**Skills principales:** {', '.join(self.cv_data['skills'])}

**Experiencia reciente:**
{self.cv_data['experience'][0]['role']} en {self.cv_data['experience'][0]['company']} ({self.cv_data['experience'][0]['years']})
‚Ä¢ {self.cv_data['experience'][0]['highlights']}

¬øHay alguna tecnolog√≠a espec√≠fica que te interese conocer m√°s?
            """
        
        elif any(word in message_lower for word in ['proyecto', 'project', 'portfolio']):
            projects_text = "üöÄ **Mis proyectos destacados:**\n\n"
            for project in self.cv_data['projects']:
                projects_text += f"**{project['name']}**\n"
                projects_text += f"Tech: {project['tech']}\n"
                projects_text += f"{project['description']}\n\n"
            
            projects_text += "¬øTe interesa alguno en particular?"
            return projects_text
        
        elif any(word in message_lower for word in ['disponible', 'available', 'contratar', 'hire']):
            return f"""
üìÖ **Disponibilidad actual:**

{self.cv_data['availability']}

¬°Me interesa saber m√°s sobre tu proyecto! 

¬øPodr√≠as contarme:
‚Ä¢ ¬øQu√© tipo de proyecto es?
‚Ä¢ ¬øQu√© tecnolog√≠as necesitas?
‚Ä¢ ¬øCu√°l es tu email para mandarte m√°s info?
            """
        
        elif any(word in message_lower for word in ['contacto', 'contact', 'email', 'tel√©fono']):
            return """
üìß **¬°Perfecto! Quieres contactar conmigo**

Para conectarte directamente, por favor comp√°rteme:
‚Ä¢ üìß Tu email (obligatorio)
‚Ä¢ üì± Tu tel√©fono (opcional) 
‚Ä¢ üíº Breve descripci√≥n del proyecto

Te responder√© en menos de 24 horas.
            """
        
        else:
            return f"""
üëã ¬°Hola! Soy {self.cv_data['name']}, {self.cv_data['title']}.

{self.cv_data['bio']}

**Puedes preguntarme sobre:**
‚Ä¢ Mi experiencia t√©cnica
‚Ä¢ Proyectos que he realizado  
‚Ä¢ Disponibilidad para nuevos proyectos
‚Ä¢ C√≥mo contactarme

¬øEn qu√© puedo ayudarte espec√≠ficamente?
            """

class TelegramBot:
    """ü§ñ Bot de Telegram usando CrewAI con YAML"""
    
    def __init__(self):
        self.digital_twin = DigitalTwin()
        self.app = Application.builder().token(TELEGRAM_TOKEN).build()
        self.setup_handlers()
        
        # Para tracking de contactos
        self.collecting_contacts = set()
    
    def setup_handlers(self):
        """Configura handlers del bot"""
        self.app.add_handler(CommandHandler("start", self.start_command))
        self.app.add_handler(CommandHandler("help", self.help_command))
        self.app.add_handler(CommandHandler("portfolio", self.portfolio_command))
        self.app.add_handler(CallbackQueryHandler(self.handle_callback))
        self.app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """üöÄ Comando inicial"""
        cv = self.digital_twin.cv_data
        
        welcome = f"""
ü§ñ **¬°Hola! Soy el asistente virtual de {cv['name']}**

*{cv['bio']}*

üìç {cv['location']}
üíº {cv['title']}
‚ö° {cv['availability']}

**¬øQu√© te interesa saber?**
        """
        
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("üíº Ver Portfolio", callback_data="portfolio"),
                InlineKeyboardButton("üöÄ Proyectos", callback_data="projects")
            ],
            [
                InlineKeyboardButton("üìß Contactar", callback_data="contact"),
                InlineKeyboardButton("‚ùì Preguntar", callback_data="ask")
            ]
        ])
        
        await update.message.reply_text(welcome, parse_mode='Markdown', reply_markup=keyboard)
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """üìã Ayuda"""
        help_text = f"""
üìã **¬øEn qu√© puedo ayudarte?**

**Preg√∫ntame sobre:**
‚Ä¢ üíª Experiencia y skills t√©cnicos
‚Ä¢ üöÄ Proyectos realizados
‚Ä¢ üìÖ Disponibilidad para proyectos
‚Ä¢ üìß C√≥mo contactar con {self.digital_twin.cv_data['name']}

**Ejemplos de preguntas:**
‚Ä¢ "¬øTienes experiencia en React?"
‚Ä¢ "¬øQu√© proyectos has hecho?"
‚Ä¢ "¬øEst√°s disponible para un proyecto?"

*¬°Solo escribe tu pregunta!*
        """
        
        await update.message.reply_text(help_text, parse_mode='Markdown')
    
    async def portfolio_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """üíº Portfolio completo"""
        cv = self.digital_twin.cv_data
        
        portfolio = f"""
üíº **Portfolio de {cv['name']}**

**üõ†Ô∏è Skills:**
{', '.join(cv['skills'])}

**üíº Experiencia:**
"""
        
        for exp in cv['experience']:
            portfolio += f"""
**{exp['role']}** @ {exp['company']} ({exp['years']})
{exp['highlights']}

"""
        
        portfolio += "**üöÄ Proyectos:**\n"
        for project in cv['projects']:
            portfolio += f"""
**{project['name']}**
Tech: {project['tech']}
{project['description']}

"""
        
        portfolio += f"**üìã Estado:** {cv['availability']}"
        
        await update.message.reply_text(portfolio, parse_mode='Markdown')
    
    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Maneja botones"""
        query = update.callback_query
        await query.answer()
        
        if query.data == "portfolio":
            await self.portfolio_command(update, context)
        elif query.data == "projects":
            await self.show_projects(query)
        elif query.data == "contact":
            await self.start_contact_collection(query)
        elif query.data == "ask":
            await query.edit_message_text(
                "‚ùì **¬°Perfecto!** Escribe tu pregunta.\n\n"
                "*Ejemplo: '¬øTienes experiencia con APIs?'*",
                parse_mode='Markdown'
            )
    
    async def show_projects(self, query):
        """Muestra proyectos"""
        projects = self.digital_twin.cv_data['projects']
        
        text = "üöÄ **Proyectos Destacados:**\n\n"
        for i, project in enumerate(projects, 1):
            text += f"""
**{i}. {project['name']}**
üõ†Ô∏è {project['tech']}
üìã {project['description']}

"""
        text += "*¬øAlguno te llama la atenci√≥n?*"
        
        await query.edit_message_text(text, parse_mode='Markdown')
    
    async def start_contact_collection(self, query):
        """Inicia recolecci√≥n de contacto"""
        user_id = query.from_user.id
        self.collecting_contacts.add(user_id)
        
        text = f"""
üìß **Contactar con {self.digital_twin.cv_data['name']}**

*¬°Perfecto! Le har√© llegar tu informaci√≥n.*

**Comparte por favor:**
‚Ä¢ üìß Tu email
‚Ä¢ üì± Tu tel√©fono (opcional)
‚Ä¢ üíº Qu√© proyecto tienes en mente

**Ejemplo:**
"Mi email es juan@empresa.com
Necesito una web con React"

*Te responder√° en menos de 24 horas.*
        """
        
        await query.edit_message_text(text, parse_mode='Markdown')
    
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Maneja mensajes de texto usando CrewAI"""
        user_id = update.effective_user.id
        message = update.message.text
        
        # Si est√° en modo recolecci√≥n de contacto
        if user_id in self.collecting_contacts:
            await self.process_contact_info(update, message)
            return
        
        # Mostrar que est√° escribiendo
        await context.bot.send_chat_action(chat_id=update.effective_chat.id, action="typing")
        
        try:
            # Procesar con Digital Twin (CrewAI)
            response = await self.digital_twin.process_query(message)
            
            # Enviar respuesta
            await update.message.reply_text(response, parse_mode='Markdown')
            
            # Detectar si muestra inter√©s en contrataci√≥n
            if any(word in message.lower() for word in ['proyecto', 'contratar', 'hire', 'trabajo', 'presupuesto']):
                await asyncio.sleep(1)
                await update.message.reply_text(
                    "üí° *¬øTe interesa? Puedo conectarte directamente con √©l usando /contact*",
                    parse_mode='Markdown'
                )
        
        except Exception as e:
            print(f"Error processing message: {e}")
            await update.message.reply_text(
                "ü§ñ *Disculpa, hubo un peque√±o error. ¬øPuedes repetir?*",
                parse_mode='Markdown'
            )
    
    async def process_contact_info(self, update: Update, message: str):
        """Procesa informaci√≥n de contacto"""
        user_id = update.effective_user.id
        user_info = update.effective_user
        
        # Extraer email (b√°sico)
        import re
        email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        emails = re.findall(email_pattern, message)
        
        if emails:
            # Guardar lead
            lead_info = {
                "email": emails[0],
                "message": message,
                "telegram_user": user_info.username or user_info.first_name,
                "user_id": user_id
            }
            
            # Enviar notificaci√≥n
            await self.send_notification(lead_info)
            
            # Confirmar al usuario
            await update.message.reply_text(
                f"""
‚úÖ **¬°Perfecto! Informaci√≥n recibida**

üìß Email: {emails[0]}
üí¨ Mensaje: ‚úì

{self.digital_twin.cv_data['name']} recibir√° tu informaci√≥n y te contactar√° pronto.

*¬°Gracias por tu inter√©s!*
                """,
                parse_mode='Markdown'
            )
            
            # Quitar de modo recolecci√≥n
            self.collecting_contacts.discard(user_id)
            
        else:
            await update.message.reply_text(
                "üìß *No veo un email v√°lido. ¬øPuedes incluirlo?*\n\n"
                "*Ejemplo: juan@empresa.com*",
                parse_mode='Markdown'
            )